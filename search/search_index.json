{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"How-To: Build generic crud functions with fastAPI Here I will show you one way to massively reduce the ammount of boilerplate code in fastAPI for standard CRUD operations of database tables in a relational database. I was faced with writing an API for an app that had many database tables that were all related to one master table. None of them were connected to each other, but each had different columns, and some had different unique row constraints etc. So not stricly homogenous but also not a verz complicated data model. I'm the kind of person that never likes to repeat themselves. And on my second copy-paste job I was already tired of that approach but I was under time pressure so pushed ahead and got the job done. Some months later I needed to perform some work on the code again with implementing additional features for the website the API was serving and I was now facing the same copy-paste hell as before, except this time I had to be extra carefull not to break the small things that changed from one table to the next. Naturally something like this should be easy to tackle with an abstract object class or two that then could be used as the buiding blocks for a general approach. But I ran into an unforeseen obstacle in that fastAPI does not allow classess as scaffolds for router-functions out of the box. After looking around and finding fastapi-utils and their class based views as well as reading this discussion on fastAPI's github issue page on a similar topic I realized this is still far from being solved and would not be solved in the timeframe I would need it in. So a plan B wasS needed. Luckily in that github discussion above, Tiangolo had made a comment that would be the beginning of a perfect solution for this project in that it produced a workable solution that could be implemented without any changes to fastAPI and eased a lot of the copy-paste pain I was facing. So I decided to pay this forward and share it with you dear reader. Before jumping into the good bits I decided to give you some background information that might help you understand the code a bit better...","title":"How-To: Build generic crud functions with fastAPI"},{"location":"#how-to-build-generic-crud-functions-with-fastapi","text":"Here I will show you one way to massively reduce the ammount of boilerplate code in fastAPI for standard CRUD operations of database tables in a relational database. I was faced with writing an API for an app that had many database tables that were all related to one master table. None of them were connected to each other, but each had different columns, and some had different unique row constraints etc. So not stricly homogenous but also not a verz complicated data model. I'm the kind of person that never likes to repeat themselves. And on my second copy-paste job I was already tired of that approach but I was under time pressure so pushed ahead and got the job done. Some months later I needed to perform some work on the code again with implementing additional features for the website the API was serving and I was now facing the same copy-paste hell as before, except this time I had to be extra carefull not to break the small things that changed from one table to the next. Naturally something like this should be easy to tackle with an abstract object class or two that then could be used as the buiding blocks for a general approach. But I ran into an unforeseen obstacle in that fastAPI does not allow classess as scaffolds for router-functions out of the box. After looking around and finding fastapi-utils and their class based views as well as reading this discussion on fastAPI's github issue page on a similar topic I realized this is still far from being solved and would not be solved in the timeframe I would need it in. So a plan B wasS needed. Luckily in that github discussion above, Tiangolo had made a comment that would be the beginning of a perfect solution for this project in that it produced a workable solution that could be implemented without any changes to fastAPI and eased a lot of the copy-paste pain I was facing. So I decided to pay this forward and share it with you dear reader. Before jumping into the good bits I decided to give you some background information that might help you understand the code a bit better...","title":"How-To: Build generic crud functions with fastAPI"},{"location":"background/","text":"Background For you to follow this writeup I recomend to familarize yourself with the SQL database howto on Tiangolo's documentation site for fastAPI. Basically he builds a simple two table model, users and items , were each user can have more than one item, and each item belongs to one user. Not that difficult to follow I hope but it shows the basic relationship I had going, except I had about 15 tables that all belonged to the user. Code layout At the time of this writing the setup of the bigger applications example found on the fastAPI documentation page is structured around having all routers in one folder, all pydantic schemas in another, etc. Although there is nothing wrong with organizing your code in this way, the more database tables you have to build APIs for and the more the database tables are connected this rather understanable type of layout starts to become confusing. Example: am I working with the schema for a user or the database model? They both have the same file name, they are just located in different folders. Ok bad example but think of the situation when you are dealing with 15 or 20 database tables? An alternative layout, keeping everything in one folder that is related to a single database table or logical object (if it makes sense e.g. to base that on more than one database table) starts to make more sense. In this example where we are talking about reducing boilerplate code in CRUD routes for many tables it would also make sense to write up the example code using this second layout. At least it makes sense to me. Feel free to structure your code as makes most sense to you of course. It will not affect the basic principle of this write up. So you will see a folder with the name users and a folder with the name items , that deal with users and items respectively. Each folder will have a file name router.py , schema.py and model.py that deal with, you guessed it the routers, schemas and models for the users or items depending in which folder they are located. Ok that was hopefully the complicated bits. Head over to the good bits to learn more about the plan B...","title":"Background"},{"location":"background/#background","text":"For you to follow this writeup I recomend to familarize yourself with the SQL database howto on Tiangolo's documentation site for fastAPI. Basically he builds a simple two table model, users and items , were each user can have more than one item, and each item belongs to one user. Not that difficult to follow I hope but it shows the basic relationship I had going, except I had about 15 tables that all belonged to the user.","title":"Background"},{"location":"background/#code-layout","text":"At the time of this writing the setup of the bigger applications example found on the fastAPI documentation page is structured around having all routers in one folder, all pydantic schemas in another, etc. Although there is nothing wrong with organizing your code in this way, the more database tables you have to build APIs for and the more the database tables are connected this rather understanable type of layout starts to become confusing. Example: am I working with the schema for a user or the database model? They both have the same file name, they are just located in different folders. Ok bad example but think of the situation when you are dealing with 15 or 20 database tables? An alternative layout, keeping everything in one folder that is related to a single database table or logical object (if it makes sense e.g. to base that on more than one database table) starts to make more sense. In this example where we are talking about reducing boilerplate code in CRUD routes for many tables it would also make sense to write up the example code using this second layout. At least it makes sense to me. Feel free to structure your code as makes most sense to you of course. It will not affect the basic principle of this write up. So you will see a folder with the name users and a folder with the name items , that deal with users and items respectively. Each folder will have a file name router.py , schema.py and model.py that deal with, you guessed it the routers, schemas and models for the users or items depending in which folder they are located. Ok that was hopefully the complicated bits. Head over to the good bits to learn more about the plan B...","title":"Code layout"},{"location":"good_bits/","text":"The good bits The basic idea is to write a function that takes as it's parameters the router object, the database table model and the pydantic models. Inside of that function you define subfunctions that act as the CRUD paths for your router and you decorate them as usuall with the router that is given as a parameter. With that approach you can then define basically instanciate an instance of this function with all the information it needs to build up a functioning CRUD path for you. Doesn't matter if you have one or fifteen tables, they all instanciate their own version of the same function with their specific database models and pydantic schemas and voila, if you ever need to go back to the code and say implement a route for not only saving a single incoming object but a list of incoming objects you build that logic once and it will be automatically available for all of your tables the next time you run your fastAPI code. Now if your are curious about the ins and outs you can read all about them in the next section, or if that is enough for you and you just want to see the code then head over to the github repository","title":"The good bits"},{"location":"good_bits/#the-good-bits","text":"The basic idea is to write a function that takes as it's parameters the router object, the database table model and the pydantic models. Inside of that function you define subfunctions that act as the CRUD paths for your router and you decorate them as usuall with the router that is given as a parameter. With that approach you can then define basically instanciate an instance of this function with all the information it needs to build up a functioning CRUD path for you. Doesn't matter if you have one or fifteen tables, they all instanciate their own version of the same function with their specific database models and pydantic schemas and voila, if you ever need to go back to the code and say implement a route for not only saving a single incoming object but a list of incoming objects you build that logic once and it will be automatically available for all of your tables the next time you run your fastAPI code. Now if your are curious about the ins and outs you can read all about them in the next section, or if that is enough for you and you just want to see the code then head over to the github repository","title":"The good bits"},{"location":"ins_and_outs/","text":"The Ins and Outs fancy code throughwalk here","title":"The Ins and Outs"},{"location":"ins_and_outs/#the-ins-and-outs","text":"fancy code throughwalk here","title":"The Ins and Outs"}]}